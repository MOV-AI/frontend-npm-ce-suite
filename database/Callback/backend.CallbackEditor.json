{
    "Callback": {
        "backend.CallbackEditor": {
            "Code": "# required keys:\n#    func - name of the method to call\n# optional keys:\n#    args - dictionary to pass to method (positional arguments not allowed)\n#\n# curl example with localhost server \n#    curl -d \"{\\\"func\\\":\\\"get_msg_struct\\\", \\\"args\\\":{\\\"message\\\": \\\"geometry_msgs/Twist\\\"}}\" -X POST http://localhost:5003/api/v1/function/SERVER3_CODEEDITOR2/\n\ndef get_libraries(*args, **kwargs):\n    return Callback.get_modules()\n\ndef init(*args, **kwargs):\n    Callback.export_modules()\n    return True\n\ndef get_all_libraries(*args, **kwargs):\n    print(\"Get all libraries called\")\n    return Callback.fetch_modules_api()\n\ndef get_messages(*args, **kwargs):\n    return Message.fetch_portdata_messages()\n    \ndef get_msg_struct(*, message, **kwargs):\n    return Message.get_structure(message)\n\ndef describe_module(*, module, **kwargs):\n    required = [\"name\", \"toSelect\"]\n    if not all(x in module for x in required):\n        return False\n    to_return = {\n        \"module\"   : Callback.get_methods(module[\"name\"]),\n        \"toSelect\" : module[\"toSelect\"],\n        \"name\"     : module[\"name\"]\n    }\n    return to_return\n    \n    # check if useful\n    for x in module:\n        if not x in required:\n            to_return[x] = module[x]\n    for element_name in dir(mymodule):\n        element = getattr(mymodule, element_name)\n        el = {\n            'value': element_name,\n            'label': element_name,\n            'name' : element_name,\n        }\n        if inspect.isclass(element):\n             try:\n                 to_return['classes'].append(el)\n             except:\n                 print(\"ERROR CLASSES\")\n        elif inspect.ismodule(element):\n            continue\n        elif hasattr(element, '__call__'):\n            if inspect.isbuiltin(element):\n                try:\n                    to_return['builtin_functions'].append(el)\n                except:\n                    print(\"ERROR BUILT-IN FUNCTION\")\n            else:\n                try:\n                    to_return['functions'].append(el)\n                except:\n                    print(\"ERROR FUNCTION\")\n                    pass\n        else:\n            try:\n                to_return['values'].append(el)\n            except:\n                print(\"ERROR VALUES\")\n    return to_return\n    \ndef handle_exception(exception):\n    exc_classname = e.__class__.__name__\n    handle_map = {\n        \"IndentationError\" : [\"filename\", \"lineno\", \"msg\", \"offset\", \"text\"], \n        \"SyntaxError\" : [\"filename\", \"lineno\", \"msg\", \"offset\", \"text\"]\n    }\n    handler = lambda e, names : {name: getattr(e, name) for name in names}\n    \n    if exc_classname in handle_map:\n        return {\"type\": exc_classname, \"data\": handler(e, handle_map[exc_classname])}\n    raise exception\n\n\nresponses = {\n    \"init\": init,\n    \"get_libraries\"  : get_libraries,\n    \"get_all_libraries\"  : get_all_libraries,\n    \"get_messages\"   : get_messages,\n    \"get_msg_struct\" : get_msg_struct,\n    \"library\"        : describe_module,\n}\n\nprint(\"MSG\",msg)\n\ntry:\n    key = msg[\"func\"]\n    args = msg.get(\"args\", {})\n    response = {\"func\": key, \"result\": responses[key](**args), \"success\": True}\nexcept Exception as e:\n    exc_result = handle_exception(e)\n    response = {\"success\": False, \"error\": exc_result}\n",
            "Label": "backend.CallbackEditor",
            "LastUpdate": {
                "date": "12/01/2021 at 09:50:04",
                "user": "movai"
            },
            "User": "manuel2",
            "VersionDelta": {},
            "Info": "",
            "Version": "",
            "Message": ""
        }
    }
}